#!/usr/bin/env python3
# Simple adapter: read JSON payload from stdin { "prompt": "...", "history": [...] }
# Call Gemini (gemini-1.5-flash) and print JSON {command, explanation, confirm}

import os, sys, json
from dotenv import load_dotenv
load_dotenv()
API_KEY = os.getenv("GEMINI_API_KEY")
if not API_KEY:
    print("ERROR: GEMINI_API_KEY not set", file=sys.stderr)
    sys.exit(2)

import google.generativeai as genai
genai.configure(api_key=API_KEY)
model = genai.GenerativeModel("gemini-1.5-flash")

# read stdin
data = sys.stdin.read()
try:
    payload = json.loads(data)
except Exception:
    payload = {"prompt": data}

prompt = payload.get("prompt", "")
history = payload.get("history", [])

# create a short prompt instructing to output JSON only
instruction = f"""
You are a Linux shell command generator.

Given the user's request, produce only a JSON object with fields:
{{ "command":"...", "explanation":"short explanation", "confirm": true|false }}

User request: {prompt}

History (most recent first):
{json.dumps(history[-5:], indent=2)}

Rules:
- produce a single-line shell command suitable for /bin/sh -c
- if the command may be destructive (delete, format, change ownership), set confirm=true
- output only valid JSON, nothing else.
"""

try:
    resp = model.generate_content(instruction)
    text = resp.text
    # Try to extract JSON
    import re
    m = re.search(r"(\{[\s\S]*\})", text)
    if m:
        out = m.group(1)
    else:
        out = text.strip()
    # Validate JSON or produce fallback
    try:
        parsed = json.loads(out)
    except Exception:
        # fallback: build naive mapping
        # naive: take first line as command
        first = text.strip().splitlines()[0]
        parsed = {"command": first, "explanation": "Autogenerated - no explanation.", "confirm": False}
    print(json.dumps(parsed))
except Exception as e:
    print(json.dumps({"command":"", "explanation": f"adapter error: {e}", "confirm": True}))
